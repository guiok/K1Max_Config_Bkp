# The MCU section only applies to the Eddy USB. For Eddy Coil you will use the MCU name of the toolboard that you connected the Eddy Coil to.
[mcu eddy]
serial: /dev/serial/by-id/usb-Klipper_rp2040_45474E621B06258A-if00 # This is the serial address of your eddy probe. This can be found by using the terminal of your klipper instance (typically through SSH) and using the command ```ls /dev/serial/by-id``` 
restart_method: command
#Did you read all of the comments before the macros? Make sure that you do and then uncomment the ones that you need. Remove this line when you are done.

[temperature_sensor btt_eddy_mcu]
sensor_type: temperature_mcu # Sets the type of sensor for Klipper to read
sensor_mcu: eddy # Sets the MCU of the eddy probe tempereature sensor
min_temp: 10 # Sets the minimum tempereature for eddys tempereature sensor to operate
max_temp: 100 # Sets the maximum tempereature for eddys tempereature sensor to operate

#[probe_eddy_current btt_eddy]
#sensor_type: ldc1612
#z_offset: 1.0
#i2c_mcu: eddy  # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the MCU you have used.
#i2c_bus: i2c0f # This value is good for the Eddy USB but would need to be adjusted for the Eddy Coil according to the I2C bus you have used.
#x_offset: 0
#y_offset: 21.42
#data_rate: 500

# This section is only relevant for Eddy USB. Comment it out for Eddy Coil.
#[temperature_probe btt_eddy]
#sensor_type: Generic 3950
#sensor_pin: eddy:gpio26
#horizontal_move_z: 2

##[bed_mesh]
##horizontal_move_z: 2
##speed: 300
# For the mesh dimensions below, the coordinates need to be reachable by the center of the probe. To calculate coordinates that will work, use the formula below:
# mesh x min = position_min_x + greater_of (15mm or x_offset) <--- in this term, only consider the x offset if it is positive, ignore if negative.
# mesh y min = position_min_y + greater_of (15mm or y_offset) <--- in this term, only consider the y offset if it is positive, ignore if negative.
# mesh x max = position_max_x - greater_of (15mm or |x_offset|) <--- in this term, only consider the x offset if it is negative, ignore if positive.
# mesh y max = position_max_y - greater_of (15mm or |y_offset|) <--- in this term, only consider the y offset if it is negative, ignore if positive.
# Example: Consider that you have a 300 x 300 bed with the max x and y positions being 300 and the min being 0. Your probe offsets are -20 for X and 10 for Y
# For mesh x min we ignore the x offset term because it is negative. Therefore mesh x min = 15
# For mesh y min we do not ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y min = 15
# For mesh x max we do not ignore the x offset term because it is negative. It is also greater than 15. Therefore mesh x max = 280
# For mesh y max we ignore the y offset term because it is positive but it is less than 15 so we use 15. Therefore mesh y max = 285
# The final result would be mesh_min: 15, 15 mesh_max: 280, 285
##mesh_min: 10, 10  # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
##mesh_max: 220, 220 # modify these according to the above guide. If the probe cannot reach then you will get a klipper error when trying to scan a bed mesh.
##probe_count: 9, 9
##algorithm: bicubic
#scan_overshoot: 8  #uncomment this section if you still have room left over on the X axis for some scan overshoot to product smoother movements and more accurate scanning. Uncommenting this should be fine if you are using a standard voron mount.

# Uncomment the lines in this macro if you are using Eddy as the probe AND the homing endstop AND would like to use the beta z-offset control
[gcode_macro SET_GCODE_OFFSET]
rename_existing: SET_GCODE_OFFSET_ORIG
variable_restored: False  # Mark whether the var has been restored from NVM
variable_runtime_offset: 0
gcode:
  SET_GCODE_OFFSET_ORIG { rawparams }

# This macro automates a lot of the frequency mapping process and simplifies the steps significantly.
[gcode_macro PROBE_EDDY_CURRENT_CALIBRATE_AUTO]
gcode:
  BED_MESH_CLEAR
  G28 X Y
  G1 X{ printer.toolhead.axis_maximum.x/2 } Y{ printer.toolhead.axis_maximum.y/2 } F6000
  {% if 'z' not in printer.toolhead.homed_axes %}
    SET_KINEMATIC_POSITION Z={ printer.toolhead.axis_maximum.z-1 } # Allows the user to work it down until it touches.
  {% endif %}
  PROBE_EDDY_CURRENT_CALIBRATE {rawparams}

#[gcode_macro BED_MESH_CALIBRATE]
#rename_existing: BTT_BED_MESH_CALIBRATE
#gcode:
#  SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=True #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg
#  BTT_BED_MESH_CALIBRATE SCAN_MODE=rapid METHOD=scan
#  SET_GCODE_VARIABLE MACRO=_KNOMI_STATUS VARIABLE=probing VALUE=False #Only uncomment this line if using a KNOMI and then remove the BED_MESH_CALIBRATE macro from KNOMI.cfg